-- @path EA=/org.msee.slmtoolbox.modeling.model/model/eaStar.ecore
-- @path BPMN=/org.msee.slmtoolbox.modeling.model/model/BPMN20.ecore

module BPMN;
create OUT: BPMN from IN: EA;

helper def: flowNodeReal: BPMN!FlowNodeRefs = OclUndefined;
helper def: flowNodeVirtual: BPMN!FlowNodeRefs = OclUndefined;

helper def: differentWorlds (source: EA!EaExtendedActivity, target: EA!EaExtendedActivity): Boolean =
	if (source.oclIsKindOf(EA!EaExtendedActivity) and target.oclIsKindOf(EA!EaExtendedActivity))
		then if (source.osmoseWorld.toString() <> target.osmoseWorld.toString())
			then true
			else false
		endif
		else false
	endif;

helper def: getWorld (source: EA!EaExtendedActivity): String = if (source.oclIsKindOf(EA!EaExtendedActivity))
		then source.osmoseWorld.toString()
		else 'undefined'
	endif;

helper def: getActivityWorld (s: EA!EaResource): String = if (s.outFlows -> collect (e | ((e).target).osmoseWorld).asSet().size() > 1)
		then 'two'
		else s.outFlows -> collect (e | ((e).target).osmoseWorld).first().toString()
	endif;

-- attribute used to store a created BPMN!Definitions instance
helper def: definitions: BPMN!Definitions = OclUndefined;

-- attribute used to store a created BPMN!Collaboration instance
helper def: collaborations: BPMN!Collaboration = OclUndefined;

helper def: bpmnFlowElements: Set(BPMN!FlowElement) = OclUndefined;

-- attribute used to store  BPMN!Process reference
helper def: bpmnProcessRef: BPMN!Process = OclUndefined;

-- attribute used to store a created BPMN!Process instance
helper def: eaStarProcessRef: EA!EaProcess = OclUndefined;

-- BPMN!MessageEventDefinition
helper def: messageEventDefinition: BPMN!MessageEventDefinition = OclUndefined;

-- get required participant for references
helper def: getParticipant(id : String): BPMN!Participant = thisModule.collaborations.participants -> select (e| e.id.toString().endsWith(id));

-- get required flowElement
helper def: getFlowElement(id: String): BPMN!FlowElement = thisModule.bpmnFlowElements -> any (e| e.id.toString().endsWith(id));
helper def: getRealFlowElement(id: String): BPMN!FlowElement = thisModule.realFlowElements -> any (e| e.id.toString().endsWith(id));
helper def: getVirtualFlowElement(id: String): BPMN!FlowElement = thisModule.virtualFlowElements -> any (e| e.id.toString().endsWith(id));

-- get all Extended Activities with human resources
helper def: getActivities_HumanRes(eaFlows : Set(EA!EaSupportFlow)): Set(EA!EaExtendedActivity) =
	eaFlows -> select (e | e.source.oclIsTypeOf(EA!EaHumanResource) and e.resourceRole.toString().startsWith('res')) -> collect (e | e.target).asSet(); 
	
-- get all Extended Activities with IT resources
helper def: getActivities_ITRes(eaFlows : Set(EA!EaSupportFlow)): Set(EA!EaExtendedActivity) =
	eaFlows -> select (e | e.source.oclIsTypeOf(EA!EaITResource) and e.resourceRole.toString().startsWith('res')) -> collect (e | e.target).asSet();

helper def: createRealUserTasks(activities: Set(EA!EaExtendedActivity)): Set(BPMN!UserTask) = 
	activities -> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and not e.isEnding and not e.isStarting and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.ExtendedRealActivity2UserTask(e)).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and  e.isEnding and  e.isStarting and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.ExtendedRealActivity2StartingEndingUserTask(e))).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and not e.isEnding and e.isStarting and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.ExtendedRealActivity2StartingUserTask(e))).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and e.isEnding and not e.isStarting and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.ExtendedRealActivity2EndingUserTask(e)));

helper def: createVirtualUserTasks(activities: Set(EA!EaExtendedActivity)): Set(BPMN!UserTask) = 
	activities -> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and not e.isEnding and not e.isStarting and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.ExtendedVirtualActivity2UserTask(e)).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and  e.isEnding and  e.isStarting and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.ExtendedVirtualActivity2StartingEndingUserTask(e))).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and not e.isEnding and e.isStarting and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.ExtendedVirtualActivity2StartingUserTask(e))).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and e.isEnding and not e.isStarting and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.ExtendedVirtualActivity2EndingUserTask(e)));

-- create ServiceTasks and test if it is a starting or ending task
helper def: createRealServiceTasks(activities: Set(EA!EaExtendedActivity)): Set(BPMN!ServiceTask) = 
	activities -> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and not e.isEnding and not e.isStarting and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.ExtendedRealActivity2ServiceTask(e)).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and  e.isEnding and  e.isStarting and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.ExtendedRealActivity2StartingEndingServiceTask(e))).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and not e.isEnding and e.isStarting and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.ExtendedRealActivity2StartingServiceTask(e))).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and e.isEnding and not e.isStarting and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.ExtendedRealActivity2EndingServiceTask(e)));

-- create ServiceTasks and test if it is a starting or ending task
helper def: createVirtualServiceTasks(activities: Set(EA!EaExtendedActivity)): Set(BPMN!ServiceTask) = 
	activities -> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and not e.isEnding and not e.isStarting and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.ExtendedVirtualActivity2ServiceTask(e)).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and  e.isEnding and  e.isStarting and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.ExtendedVirtualActivity2StartingEndingServiceTask(e))).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and not e.isEnding and e.isStarting and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.ExtendedVirtualActivity2StartingServiceTask(e))).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and e.isEnding and not e.isStarting and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.ExtendedVirtualActivity2EndingServiceTask(e)));

helper def: createRealTasks(activities: Set(EA!EaExtendedActivity)): Set(BPMN!Task) = 
	activities -> select(e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and not e.isEnding and not e.isStarting and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.ExtendedRealActivity2Task(e)).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and  e.isEnding and  e.isStarting and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.ExtendedRealActivity2StartingEndingTask(e))).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and not e.isEnding and e.isStarting and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.ExtendedRealActivity2StartingTask(e))).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and e.isEnding and not e.isStarting and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.ExtendedRealActivity2EndingTask(e)));

helper def: createVirtualTasks(activities: Set(EA!EaExtendedActivity)): Set(BPMN!Task) = 
	activities -> select(e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and not e.isEnding and not e.isStarting and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.ExtendedVirtualActivity2Task(e)).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and  e.isEnding and  e.isStarting and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.ExtendedVirtualActivity2StartingEndingTask(e))).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and not e.isEnding and e.isStarting and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.ExtendedVirtualActivity2StartingTask(e))).union(activities 
	-> select (e | e.oclIsTypeOf(EA!EaAtomicExtendedActivity) and e.isEnding and not e.isStarting and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.ExtendedVirtualActivity2EndingTask(e)));

-- get all resources which are responsible for the execution of activities
helper def: getResponsibleResources(flows: OrderedSet(EA!EaSupportFlow)): OrderedSet(EA!EaResource) = 
	flows -> select(e | e.resourceRole.toString().startsWith('res') and thisModule.isFirstOrganization(e.target.organization)) 
	-> collect ( e| e.source).asOrderedSet();

-- test if an organization is the first organization in the list (default organization)
helper def: isFirstOrganization(organization: EA!EaOrganization): Boolean = if (thisModule.eaStarProcessRef.model.organizations.indexOf(organization) <= 1 )
		then true
		else false
	endif;

-- create lanes with respect to responsible resources
helper def: createLanes(resources: Set(EA!EaResource)): Set(BPMN!Lane) = resources -> collect(e| thisModule.Resource2Lane(e));

-- create lanes with respect to organization
helper def: createLanesForOrganization(organizations: Set(EA!EaOrganization)): Set(BPMN!Lane) = organizations -> collect(e| thisModule.Organization2Lane(e));

-- get all the support flows 
helper def: getAllSupportFlows(flowElements: Set(EA!EaFlowElement)): Set(EA!EaSupportFlow) = flowElements -> select(e | e.oclIsTypeOf(EA!EaSupportFlow));

-- create flowNodeRefs in a lane for resource
helper def: createFlowNodeRefs(resourceid: String): Set(BPMN!Activity) = thisModule.getAllSupportFlows(thisModule.eaStarProcessRef.flowElements) 
	-> select(e | e.source.id.startsWith(resourceid) and e.resourceRole.toString().startsWith('res')) -> collect(e | e.target); 

-- create flowNodeRefs in a lane for organization
helper def: createFlowNodeRefsForOrganization(organizationid: String): Set(BPMN!Activity) = 
	thisModule.getAllExtendedActivities() -> select(e | not e.organization.oclIsUndefined()) -> select(e | e.organization.id.startsWith(organizationid)); 

helper def: getAllExtendedActivities(): Set(EA!EaExtendedActivity) = 
	thisModule.eaStarProcessRef.flowElements -> select(e | e.oclIsKindOf(EA!EaExtendedActivity));

-- check if an Extended Activity is atomic or structural
helper def: isAtomic(ea: EA!ExtendedActivity) : Boolean = if (ea.oclIsTypeOf(EA!EaAtomicExtendedActivity))
		then  true
		else false
	endif;

-- check if source of a flow is Material Resource 
helper def: isMaterialResource(support: EA!EaResource): Boolean = support.oclIsTypeOf(EA!EaMaterialResource);

helper def: searchRealProcess(s: BPMN!Process): Boolean = if ((s.laneSets -> select (e | e.id = 'RealWorldLaneSet')).size() > 0)
	then true
	else false
	endif;

helper def: searchVirtualProcess(s: BPMN!Process): Boolean = if ((s.laneSets -> select (e | e.id = 'VirtualWorldLaneSet')).size() > 0)
	then true
	else false
	endif;

helper def: detectLane(s: BPMN!Lane, c: BPMN!Task): Boolean = if (s.flowNodeRefs -> select (e | e.id.toString() = c.id.toString()) -> isEmpty())
	then false
	else true
	endif;

helper def: getLane(s: BPMN!Task): BPMN!Lane = BPMN!Lane.allInstances() -> collect (e | e) -> select (e | thisModule.detectLane(e, s)).first();

-- create subprocess from Structural Extended Activity
helper def: createRealSubProcess(activities: Set(EA!EaStructuralExtendedActivity)): Set(BPMN!SubProcess) = activities 
	-> select(e | e.isStarting and not e.isEnding and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.StructuralRealExtendedActivity2StartingSubProcess(e)).union(activities 
	-> select(e | not e.isStarting and e.isEnding and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.StructuralRealExtendedActivity2EndingSubProcess(e))).union(activities 
	-> select(e | e.isStarting and e.isEnding and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.StructuralRealExtendedActivity2StartingEndingSubProcess(e))).union(activities 
	-> select(e | not e.isStarting and not e.isEnding and e.osmoseWorld = 'REAL') 
	-> collect(e | thisModule.StructuralRealExtendedActivity2SubProcess(e)));

-- create subprocess from Structural Extended Activity
helper def: createVirtualSubProcess(activities: Set(EA!EaStructuralExtendedActivity)): Set(BPMN!SubProcess) = activities 
	-> select(e | e.isStarting and not e.isEnding and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.StructuralVirtualExtendedActivity2StartingSubProcess(e)).union(activities 
	-> select(e | not e.isStarting and e.isEnding and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.StructuralVirtualExtendedActivity2EndingSubProcess(e))).union(activities 
	-> select(e | e.isStarting and e.isEnding and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.StructuralVirtualExtendedActivity2StartingEndingSubProcess(e))).union(activities 
	-> select(e | not e.isStarting and not e.isEnding and e.osmoseWorld = 'VIRTUAL') 
	-> collect(e | thisModule.StructuralVirtualExtendedActivity2SubProcess(e)));

----------------------------------------------------------------------------------------------------
----------------------------------------------------------------------------------------------------
helper def: bpmnProcess: Set(BPMN!Process) = OclUndefined;
helper def: realWorldLanes: Set(String) = OclUndefined;
helper def: virtualWorldLanes: Set(String) = OclUndefined;
helper def: bpmnOrgLanes: Set(BPMN!Lane) = OclUndefined;
helper def: laneSet: Set(BPMN!LaneSet) = OclUndefined;
helper def: orgChildLaneSet: Set(BPMN!LaneSet) = OclUndefined;

helper def: getNamedLaneSet(laneSet: String): BPMN!LaneSet = thisModule.laneSet -> select(e | e.id = laneSet); 

helper def: getOrgLaneSet(laneSet: String): BPMN!LaneSet = thisModule.orgChildLaneSet -> select(e | e.id = laneSet)-> first(); 

helper def: getRealNamedLane(lane: String): BPMN!Lane = thisModule.realWorldLanes -> select(e | e.id = lane);
helper def: getVirtualNamedLane(lane: String): BPMN!Lane = thisModule.virtualWorldLanes -> select(e | e.id = lane);

helper def: membraneFlowElements: Set(BPMN!FlowElement) = OclUndefined;
helper def: virtualizationFlowElements: Set(BPMN!FlowElement) = OclUndefined;
helper def: virtualFlowElements: Set(BPMN!FlowElement) = OclUndefined;
helper def: realFlowElements: Set(BPMN!FlowElement) = OclUndefined;
-----------------------------------------------------------------------------------------
-----------------------------------------------------------------------------------------
entrypoint rule init() {
	to 
		a: BPMN!Collaboration (
			name <- 'collaboration',
			id <- 'collaboration_1'
		),
		real: BPMN!LaneSet(
			name <- 'RealWorldLaneSet',
			id <- 'RealWorldLaneSet',
			lanes <- thisModule.realWorldLanes
		),
		osmose: BPMN!LaneSet(
			name <- 'OsmoseWorldLaneSet',
			id <- 'OsmoseLaneSet'
		),
		virtual: BPMN!LaneSet(
			name <- 'VirtualWorldLaneSet',
			id <- 'VirtualWorldLaneSet',
			lanes <- thisModule.virtualWorldLanes			
		),
		c: BPMN!Process(
			name <- 'ProcessToStoreFlowElements',
			id <- 'processStore'
		)
	do {
		--thisModule.bpmnProcessRef.artifacts <- Set{};
		thisModule.flowNodeReal <- Set{};
		thisModule.flowNodeVirtual <- Set{};
		thisModule.realWorldLanes <- Set{};
		thisModule.virtualWorldLanes <- Set{};
		thisModule.bpmnProcess <- Set{};
		thisModule.orgChildLaneSet <- Set{};
		thisModule.bpmnOrgLanes <- Set{};
		thisModule.bpmnFlowElements <- Set{};
		thisModule.membraneFlowElements <- Set{};
		thisModule.virtualizationFlowElements <- Set {};
		thisModule.virtualFlowElements <- Set{};
		thisModule.realFlowElements <- Set{};
		thisModule.MembraneStartingTask();
		thisModule.MembraneElements();
		thisModule.VirtualizationElements();
		thisModule.MembraneSequenceFlows();
		thisModule.VirtualizationSequenceFlows();	
		thisModule.collaborations <- a;
		thisModule.laneSet <- Set {real, osmose, virtual};
	}
}

-- transform an ExtendedActigram element to a Definition element
rule ExtendedActigramToDefinition {
	from
		s: EA!EaModel
	to
		a: BPMN!Definitions (
			id <- s.name,
			name <- s.process.osmioticProcess.toString(),
			targetNamespace <- 'http://www.jboss.org/drools',
			expressionLanguage <- 'http://www.mvel.org/2.0',
			typeLanguage <- 'http://www.java.com/javaTypes',
			rootElements <- Set {s.process.flowElements -> select(e | e.oclIsTypeOf(EA!EaExternalConnector) or e.oclIsTypeOf(EA!EaInternalConnector)) 
				-> collect(e | thisModule.InExternalConnector2Process(e)).insertAt(1, thisModule.ProcessToProcess(s.process)).
				append(thisModule.collaborations), thisModule.bpmnProcess}
		)
	do {
		--let s: String = '' in 'definition'.println(); 
	}
}

-- --------------------------------------------
-- transform a Process element to a BPMN Process element
lazy rule ProcessToProcess {
	from
		s: EA!EaProcess (s.oclIsTypeOf(EA!EaProcess))
	to
		real: BPMN!Process (
			id <- s.id,
			name <- s.name,
			laneSets <- thisModule.getNamedLaneSet('RealWorldLaneSet'),
			flowElements <- s.flowElements.
			append(thisModule.createRealUserTasks(thisModule.getActivities_HumanRes(s.flowElements -> select (e | e.oclIsTypeOf(EA!EaSupportFlow))))).
			append(thisModule.createRealServiceTasks(thisModule.getActivities_ITRes(s.flowElements -> select (e | e.oclIsTypeOf(EA!EaSupportFlow))))).
			append(thisModule.createRealTasks(s.flowElements -> select (e | e.oclIsKindOf(EA!EaExtendedActivity)) 
				-> select(e | (thisModule.getActivities_HumanRes(s.flowElements -> select (e | e.oclIsTypeOf(EA!EaSupportFlow))).
				union(thisModule.getActivities_ITRes(s.flowElements -> select (e | e.oclIsTypeOf(EA!EaSupportFlow))))).excludes(e))))
			.append(s.flowElements -> select (e | e.oclIsTypeOf(EA!EaOr)) -> collect (e | thisModule.Or2ExclusiveGateway(e)))
			.append(s.flowElements -> select (e | e.oclIsTypeOf(EA!EaAnd)) -> collect (e | thisModule.And2ParallelGateway(e)))
			.append(s.flowElements -> select (e | e.oclIsTypeOf(EA!EaMaterialResource)) -> collect (e | thisModule.Material2DataObject(e)))
			.append(s.flowElements -> select (e | e.oclIsTypeOf(EA!EaProcessConnector)) -> collect (e | thisModule.ProcessConnector2CallActivity(e)))
			.append(thisModule.createRealSubProcess(s.flowElements -> select(e | e.oclIsTypeOf(EA!EaStructuralExtendedActivity))))
		),
		realp: BPMN!Participant (
			id <- s.id + '_Participant',
			name <- 'Real World',
			processRef <- real
		),
		osmose: BPMN!Process(
			name <- 'Osmose Process',
			id <- 'osmoseProcess',
			laneSets <- thisModule.getNamedLaneSet('OsmoseLaneSet'),
			flowElements <- thisModule.membraneFlowElements.union(thisModule.virtualizationFlowElements)
		),
		osmosep: BPMN!Participant (
			id <- osmose.id + '_Participant',
			name <- 'Osmose Platform',
			processRef <- osmose
		),
		virtual:BPMN!Process(
			name <-'Virtual World Process',
			id <- 'virtuaWorldProcess',
			laneSets <- thisModule.getNamedLaneSet('VirtualWorldLaneSet'),
			flowElements <- s.flowElements.
			append(thisModule.createVirtualUserTasks(thisModule.getActivities_HumanRes(s.flowElements -> select (e | e.oclIsTypeOf(EA!EaSupportFlow))))).
			append(thisModule.createVirtualServiceTasks(thisModule.getActivities_ITRes(s.flowElements -> select (e | e.oclIsTypeOf(EA!EaSupportFlow))))).
			append(thisModule.createVirtualTasks(s.flowElements -> select (e | e.oclIsKindOf(EA!EaExtendedActivity)) 
				-> select(e | (thisModule.getActivities_HumanRes(s.flowElements -> select (e | e.oclIsTypeOf(EA!EaSupportFlow))).
				union(thisModule.getActivities_ITRes(s.flowElements -> select (e | e.oclIsTypeOf(EA!EaSupportFlow))))).excludes(e))))
			--.append(s.flowElements -> select (e | e.oclIsTypeOf(EA!EaMaterialResource)) -> collect (e | thisModule.Material2DataObject(e)))
			.append(s.flowElements -> select (e | e.oclIsTypeOf(EA!EaProcessConnector)) -> collect (e | thisModule.ProcessConnector2CallActivity(e)))
			.append(thisModule.createVirtualSubProcess(s.flowElements -> select(e | e.oclIsTypeOf(EA!EaStructuralExtendedActivity))))
		),
		virtualp: BPMN!Participant (
			id <- virtual.id + '_Participant',
			name <- 'Virtual World',
			processRef <- virtual
		)
	do {
		real.flowElements <- (real.flowElements).union(thisModule.realFlowElements);
		virtual.flowElements <- (virtual.flowElements).union(thisModule.virtualFlowElements);
		
		real.artifacts <- Set {};
		virtual.artifacts <- Set {};
		
		osmose.flowElements <- osmose.flowElements.union(thisModule.membraneFlowElements).union(thisModule.virtualizationFlowElements);
		
		thisModule.bpmnProcess <- Set {real, osmose, virtual};
		
		thisModule.collaborations.participants <- Set {osmosep, virtualp, realp};
		thisModule.eaStarProcessRef <- s;
		
		thisModule.CreateLane('Membrane', thisModule.getNamedLaneSet('OsmoseLaneSet') -> first());
		thisModule.CreateLane('Virtualization', thisModule.getNamedLaneSet('OsmoseLaneSet') -> first());
	}
}

------------------------------------------- REAL WORLD ------------------------------------------------------------
-- transform Structural Extended Activity to subProcess
lazy rule StructuralRealExtendedActivity2SubProcess {
	from
		s: EA!EaStructuralExtendedActivity (not s.isStarting and not s.isEnding)	
	to
		a: BPMN!SubProcess (
			id <- s.id,
			name <- s.name
		)
	do {
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform Structural Extended Activity to starting subProcess
lazy rule StructuralRealExtendedActivity2StartingSubProcess {
	from
		s: EA!EaStructuralExtendedActivity (s.isStarting and not s.isEnding)
	to
		a: BPMN!SubProcess (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- b,
			targetRef <- a
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(b);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform Structural Extended Activity to ending subProcess
lazy rule StructuralRealExtendedActivity2EndingSubProcess {
	from
		s: EA!EaStructuralExtendedActivity (not s.isStarting and s.isEnding)
	to
		a: BPMN!SubProcess (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1_EndEvent',
			sourceRef <- a,
			targetRef <- b
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(b);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform Structural Extended Activity to ending subProcess
lazy rule StructuralRealExtendedActivity2StartingEndingSubProcess {
	from
		s: EA!EaStructuralExtendedActivity (s.isStarting and s.isEnding)
	to
		a: BPMN!SubProcess (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- a,
			targetRef <- b
		),
		d: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		e: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- d,
			targetRef <- a
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(b);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(c);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(d);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(e);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform atomic Extended Activity to task
lazy rule ExtendedRealActivity2Task {
	from
		s: EA!EaAtomicExtendedActivity(not s.isStarting and not s.isEnding)
	to
		a: BPMN!Task (
			id <- s.id,
			name <- s.name
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform starting atomic Extended Activity to Usertask
lazy rule ExtendedRealActivity2StartingTask {
	from
		s: EA!EaAtomicExtendedActivity(s.isStarting	and not s.isEnding)
	to
		a: BPMN!UserTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- b,
			targetRef <- a
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(b);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform an ending atomic Extended Activity to Usertask
lazy rule ExtendedRealActivity2EndingTask {
	from
		s: EA!EaAtomicExtendedActivity(not s.isStarting	and  s.isEnding)
	to
		a: BPMN!UserTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- a,
			targetRef <- b
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(b);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform starting ending atomic Extended Activity to Usertask
lazy rule ExtendedRealActivity2StartingEndingTask {
	from
		s: EA!EaAtomicExtendedActivity(s.isStarting	and s.isEnding)
	to
		a: BPMN!UserTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- b,
			targetRef <- a
		),
		d: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		e: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_2',
			sourceRef <- a,
			targetRef <- d
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(b);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(c);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(d);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(e);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform atomic Extended Activity to Usertask
lazy rule ExtendedRealActivity2UserTask {
	from
		s: EA!EaAtomicExtendedActivity(not s.isStarting and not s.isEnding)
	to
		a: BPMN!UserTask (
			id <- s.id,
			name <- s.name
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform starting atomic Extended Activity to Usertask
lazy rule ExtendedRealActivity2StartingUserTask {
	from
		s: EA!EaAtomicExtendedActivity(s.isStarting	and not s.isEnding)
	to
		a: BPMN!UserTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- b,
			targetRef <- a
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(b);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform an ending atomic Extended Activity to Usertask
lazy rule ExtendedRealActivity2EndingUserTask {
	from
		s: EA!EaAtomicExtendedActivity(not s.isStarting	and  s.isEnding)
	to
		a: BPMN!UserTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- a,
			targetRef <- b
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(b);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform starting ending atomic Extended Activity to Usertask
lazy rule ExtendedRealActivity2StartingEndingUserTask {
	from
		s: EA!EaAtomicExtendedActivity(s.isStarting	and s.isEnding)
	to
		a: BPMN!UserTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- b,
			targetRef <- a
		),
		d: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		e: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_2',
			sourceRef <- a,
			targetRef <- d
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(b);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(c);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(d);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(e);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform atomic Extended Activity to Servicetask
lazy rule ExtendedRealActivity2ServiceTask {
	from
		s: EA!EaAtomicExtendedActivity(not s.isStarting and not s.isEnding)
	to
		a: BPMN!ServiceTask (
			id <- s.id,
			name <- s.name
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform a starting atomic Extended Activity to Usertask
lazy rule ExtendedRealActivity2StartingServiceTask {
	from
		s: EA!EaAtomicExtendedActivity(s.isStarting	and not s.isEnding)
	to
		a: BPMN!ServiceTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- b,
			targetRef <- a
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(b);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform an ending atomic Extended Activity to Usertask
lazy rule ExtendedRealActivity2EndingServiceTask {
	from
		s: EA!EaAtomicExtendedActivity(not s.isStarting and s.isEnding)
	to
		a: BPMN!ServiceTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- a,
			targetRef <- b
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(b);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform starting ending atomic Extended Activity to Usertask
lazy rule ExtendedRealActivity2StartingEndingServiceTask {
	from
		s: EA!EaAtomicExtendedActivity(s.isStarting	and s.isEnding)
	to
		a: BPMN!ServiceTask(
			id <- s.id,
			name <- s.name	
		),
		b: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		c: BPMN!SequenceFlow(
			id <- s.id + 'Sequence_1',
			sourceRef <- b,
			targetRef <- a
		),
		d: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		e: BPMN!SequenceFlow(
			id <- s.id + 'Sequence_2',
			sourceRef <- a,
			targetRef <- d
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(b);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(c);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(d);
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(e);
		--let s: String = '' in a.name.toString().println(); 
	}
}

------------------------------------------- VIRTUAL WORLD ------------------------------------------------------------
-- transform Structural Extended Activity to subProcess
lazy rule StructuralVirtualExtendedActivity2SubProcess {
	from
		s: EA!EaStructuralExtendedActivity (not s.isStarting and not s.isEnding)	
	to
		a: BPMN!SubProcess (
			id <- s.id,
			name <- s.name
		)
	do {
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform Structural Extended Activity to starting subProcess
lazy rule StructuralVirtualExtendedActivity2StartingSubProcess {
	from
		s: EA!EaStructuralExtendedActivity (s.isStarting and not s.isEnding)
	to
		a: BPMN!SubProcess (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- b,
			targetRef <- a
		)
	do {
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(b);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform Structural Extended Activity to ending subProcess
lazy rule StructuralVirtualExtendedActivity2EndingSubProcess {
	from
		s: EA!EaStructuralExtendedActivity(not s.isStarting and s.isEnding)
	to
		a: BPMN!SubProcess (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1_EndEvent',
			sourceRef <- a,
			targetRef <- b
		)
	do {
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(b);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform Structural Extended Activity to ending subProcess
lazy rule StructuralVirtualExtendedActivity2StartingEndingSubProcess {
	from
		s: EA!EaStructuralExtendedActivity(s.isStarting and s.isEnding)
	to
		a: BPMN!SubProcess(
			id <- s.id,
			name <- s.name
		),
		b: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- a,
			targetRef <- b
		),
		d: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		e: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- d,
			targetRef <- a
		)
	do {
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(b);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(c);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(d);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(e);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform atomic Extended Activity to task
lazy rule ExtendedVirtualActivity2Task {
	from
		s: EA!EaAtomicExtendedActivity(not s.isStarting and not s.isEnding)
	to
		a: BPMN!Task (
			id <- s.id,
			name <- s.name
		)
	do {
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform starting atomic Extended Activity to Usertask
lazy rule ExtendedVirtualActivity2StartingTask {
	from
		s: EA!EaAtomicExtendedActivity(s.isStarting	and not s.isEnding)
	to
		a: BPMN!UserTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- b,
			targetRef <- a
		)
	do {
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(b);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform an ending atomic Extended Activity to Usertask
lazy rule ExtendedVirtualActivity2EndingTask {
	from
		s: EA!EaAtomicExtendedActivity(not s.isStarting	and  s.isEnding)
	to
		a: BPMN!UserTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- a,
			targetRef <- b
		)
	do {
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(b);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform starting ending atomic Extended Activity to Usertask
lazy rule ExtendedVirtualActivity2StartingEndingTask {
	from
		s: EA!EaAtomicExtendedActivity(s.isStarting	and s.isEnding)
	to
		a: BPMN!UserTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- b,
			targetRef <- a
		),
		d: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		e: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_2',
			sourceRef <- a,
			targetRef <- d
		)
	do {
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(b);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(c);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(d);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(e);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform atomic Extended Activity to Usertask
lazy rule ExtendedVirtualActivity2UserTask {
	from
		s: EA!EaAtomicExtendedActivity(not s.isStarting and not s.isEnding)
	to
		a: BPMN!UserTask (
			id <- s.id,
			name <- s.name
		)
	do {
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform starting atomic Extended Activity to Usertask
lazy rule ExtendedVirtualActivity2StartingUserTask {
	from
		s: EA!EaAtomicExtendedActivity(s.isStarting	and not s.isEnding)
	to
		a: BPMN!UserTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- b,
			targetRef <- a
		)
	do {
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(b);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform an ending atomic Extended Activity to Usertask
lazy rule ExtendedVirtualActivity2EndingUserTask {
	from
		s: EA!EaAtomicExtendedActivity(not s.isStarting	and s.isEnding)
	to
		a: BPMN!UserTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- a,
			targetRef <- b
		)
	do {
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(b);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform starting ending atomic Extended Activity to Usertask
lazy rule ExtendedVirtualActivity2StartingEndingUserTask {
	from
		s: EA!EaAtomicExtendedActivity(s.isStarting	and s.isEnding)
	to
		a: BPMN!UserTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- b,
			targetRef <- a
		),
		d: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		e: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_2',
			sourceRef <- a,
			targetRef <- d
		)
	do {
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(b);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(c);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(d);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(e);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform atomic Extended Activity to Servicetask
lazy rule ExtendedVirtualActivity2ServiceTask {
	from
		s: EA!EaAtomicExtendedActivity( not s.isStarting and not s.isEnding)
	to
		a: BPMN!ServiceTask (
			id <- s.id,
			name <- s.name
		)
	do {
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform a starting atomic Extended Activity to Usertask
lazy rule ExtendedVirtualActivity2StartingServiceTask {
	from
		s: EA!EaAtomicExtendedActivity(s.isStarting	and not s.isEnding)
	to
		a: BPMN!ServiceTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- b,
			targetRef <- a
		)
	do {
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(b);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform an ending atomic Extended Activity to Usertask
lazy rule ExtendedVirtualActivity2EndingServiceTask {
	from
		s: EA!EaAtomicExtendedActivity( not s.isStarting and s.isEnding)
	to
		a: BPMN!ServiceTask (
			id <- s.id,
			name <- s.name
		),
		b: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- a,
			targetRef <- b
		)
	do {
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(b);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(c);
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform starting ending atomic Extended Activity to Usertask
lazy rule ExtendedVirtualActivity2StartingEndingServiceTask {
	from
		s: EA!EaAtomicExtendedActivity(s.isStarting	and s.isEnding)
	to
		a: BPMN!ServiceTask (
			id <- s.id,
			name <- s.name	
		),
		b: BPMN!StartEvent(
			id <- s.id + 'Start',
			name <- 'StartEvent'
		),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- b,
			targetRef <- a
		),
		d: BPMN!EndEvent(
			id <- s.id + 'End',
			name <- 'EndEvent'
		),
		e: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_2',
			sourceRef <- a,
			targetRef <- d
		)
	do {
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(b);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(c);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(d);
		thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(e);
		--let s: String = '' in a.name.toString().println(); 
	}
}

------------------------------------------- OLD CODE -----------------------------------------------------------------------------
lazy rule Or2ExclusiveGateway {
	from 
		s: EA!EaOr
	to
		a: BPMN!ExclusiveGateway(
			id <- s.id,
			name <- s.name,
			gatewayDirection <- if (s.inFlows.size() > 1)
				then if (s.outFlows.size() > 1)
					then 'Mixed'
					else 'Converging'
					endif
				else 'Diverging' 
				endif
		)	
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);	
	}
}

lazy rule And2ParallelGateway {
	from 
		s:EA!EaAnd
	to
		a: BPMN!ParallelGateway(
		id <- s.id,
		name <- s.name,
			gatewayDirection <- if (s.inFlows.size() > 1)
				then if (s.outFlows.size() > 1)
					then 'Mixed'
					else 'Converging'
					endif
				else 'Diverging' 
				endif
		)
	do {
		thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);		
	}
}

-- transform an OutputInput Flow to a message flow(1)
-- rule to transform flow connecting a "connector" to and "Activity" (beginning of the diagram)
rule outputInput2MessageFlow1 {
	from
		s: EA!EaOutputInputFlow ((s.source.oclIsTypeOf(EA!EaExternalConnector) or s.source.
			oclIsTypeOf(EA!EaInternalConnector)) and (s.target.oclIsKindOf(EA!EaExtendedActivity) and thisModule.isAtomic(s.target)))
	to	
		a: BPMN!MessageFlow(
			id <- s.id + '22222',
			name <- s.name + '22222',
			sourceRef <- thisModule.getParticipant(s.source.id + '_Participant' ),
			targetRef <- s.target
		)
	do {
		thisModule.collaborations.messageFlows <- thisModule.collaborations.messageFlows.append(a);
		--let x: String = '' in s.target.id.toString().println(); 
	}
}

-- transform an OutputInput Flow to a message flow(2)
-- rule to transform flow connecting an "Activity" to a "connector" (end of the diagram)
rule outputInput2MessageFlow2 {
	from
		s: EA!EaOutputInputFlow ((s.source.oclIsKindOf(EA!EaExtendedActivity) and  thisModule.isAtomic(s.source)) 
			and (s.target.oclIsTypeOf(EA!EaExternalConnector) or s.target.oclIsTypeOf(EA!EaInternalConnector)))
	to	
		a: BPMN!MessageFlow(
			id <- s.id,
			name <- s.name,
			sourceRef <- s.source,
			targetRef <- thisModule.getParticipant(s.target.id  + '_Participant')
		)
	do {
		thisModule.collaborations.messageFlows <- thisModule.collaborations.messageFlows.append(a);
		--let s: String = '' in s.source.id.toString().println(); 
	}
}

-- rule to transform flow connecting "Activities" belonging to different worlds
-- !!!! It is only considered that world transitions occur in flows connecting 2 activities  !!!!
rule outputInput2MessageFlow3 {
	from 
		s: EA!EaOutputInputFlow((thisModule.differentWorlds(s.source, s.target) and 
			(s.source.oclIsKindOf(EA!EaExtendedActivity) and s.target.oclIsKindOf(EA!EaExtendedActivity)))
		)
	to
		a: BPMN!MessageFlow(
			id <- s.id + '_ChangeWorld1',
			name <- s.id + '_ChangeWorld1',
			sourceRef <- s.source,
			targetRef <- BPMN!Task.allInstances() -> collect (e | e) -> select (e | e.id = 'waitingForEvent').first()
		),
		b: BPMN!MessageFlow(
			id <- s.id + '_ChangeWorld2',
			name <- s.id + '_ChangeWorld2',
			sourceRef <- BPMN!Task.allInstances() -> collect (e | e) -> select (e | e.id = 'TaskToEnd').first(),
			targetRef <- s.target
		)
	do { 
		thisModule.collaborations.messageFlows <- thisModule.collaborations.messageFlows.append(a);
		thisModule.collaborations.messageFlows <- thisModule.collaborations.messageFlows.append(b);
	}
}

-- transform an OutputInput Flow to a sequence flow
-- rule to transform flow connecting activities from the same world
rule outputInput2SequenceFlow1 {
	from 
		s: EA!EaOutputInputFlow((not thisModule.differentWorlds(s.source, s.target) and thisModule.getWorld(s.source) = 'undefined' and
			(s.source.oclIsKindOf(EA!EaExtendedActivity) and s.target.oclIsKindOf(EA!EaExtendedActivity))))
	to
		a: BPMN!SequenceFlow(
			id <- s.id + '_Sequence',
			name <- s.name,
			sourceRef <- thisModule.getRealFlowElement(s.source.id),
			targetRef <- thisModule.getRealFlowElement(s.target.id)
		)
	do { }
}

rule outputRealInput2SequenceFlow1 {
	from 
		s: EA!EaOutputInputFlow((not thisModule.differentWorlds(s.source, s.target) and thisModule.getWorld(s.source) = 'REAL' and
			(s.source.oclIsKindOf(EA!EaExtendedActivity) and s.target.oclIsKindOf(EA!EaExtendedActivity))))
	to
		a: BPMN!SequenceFlow(
			id <- s.id + '_Sequence',
			name <- s.name,
			sourceRef <- thisModule.getRealFlowElement(s.source.id),
			targetRef <- thisModule.getRealFlowElement(s.target.id)
		)
	do { }
}

rule outputVirtualInput2SequenceFlow1 {
	from 
		s: EA!EaOutputInputFlow((not thisModule.differentWorlds(s.source, s.target) and thisModule.getWorld(s.source) = 'VIRTUAL' and
			(s.source.oclIsKindOf(EA!EaExtendedActivity) and s.target.oclIsKindOf(EA!EaExtendedActivity))))
	to
		a: BPMN!SequenceFlow(
			id <- s.id + '_Sequence',
			name <- s.name,
			sourceRef <- thisModule.getVirtualFlowElement(s.source.id),
			targetRef <- thisModule.getVirtualFlowElement(s.target.id)
		)
	do { }
}

-- transform an OutputInput Flow to a sequence flow
-- rules to transform flow connecting any other elements
rule outputInput2SequenceFlow2 {
	from 
		s: EA!EaOutputInputFlow ((s.source.oclIsTypeOf(EA!EaProcessConnector) or s.source.oclIsKindOf(EA!EaExtendedActivity)
			or s.source.oclIsTypeOf(EA!EaAnd) or s.source.oclIsTypeOf(EA!EaOr)) 
			and (s.target.oclIsTypeOf(EA!EaAnd) or s.target.oclIsTypeOf(EA!EaOr) or s.target.oclIsTypeOf(EA!EaProcessConnector))
		)
	to
		a: BPMN!SequenceFlow(
			id <- s.id + '_Sequence',
			name <- s.name,
			sourceRef <- thisModule.getRealFlowElement(s.source.id),
			targetRef <- thisModule.getRealFlowElement(s.target.id)
		)
	do { }
}

rule outputInput2SequenceFlow3 {
	from 
		s: EA!EaOutputInputFlow((s.source.oclIsTypeOf(EA!EaProcessConnector) or s.source.oclIsTypeOf(EA!EaAnd) 
				or s.source.oclIsTypeOf(EA!EaOr)) and (s.target.oclIsKindOf(EA!EaExtendedActivity) or s.target.oclIsTypeOf(EA!EaAnd) 
				or s.target.oclIsTypeOf(EA!EaOr) or s.target.oclIsTypeOf(EA!EaProcessConnector))
		)
	to
		a: BPMN!SequenceFlow(
		id <- s.id + '_Sequence',
		name <- s.name,
		sourceRef <- thisModule.getRealFlowElement(s.source.id),
		targetRef <- thisModule.getRealFlowElement(s.target.id)
	)
	do { }
}

-- transform an OutputInput flow to CatchingMessageEvent, MessageFlow, and SequenceFlow
rule outputInput2CatchingMessage_MessageFlow_SequenceFlow {
	from
		s: EA!EaOutputInputFlow ((s.source.oclIsTypeOf(EA!EaExternalConnector) or s.source.oclIsTypeOf(EA!EaInternalConnector)) and 
			((s.target.oclIsKindOf(EA!EaExtendedActivity) and  not thisModule.isAtomic(s.target)) 
			or s.target.oclIsTypeOf(EA!EaAnd) or s.target.oclIsTypeOf(EA!EaOr)))
	to
		a:	BPMN!IntermediateCatchEvent(
			id <- s.id + 'Catch_1',
			name <- 'MessageCatchEvent',
			eventDefinitions <- thisModule.messageEventDefinition
			),			
		b: BPMN!MessageFlow(
			id <- s.id + 'Message_1',
			sourceRef <- thisModule.getParticipant(s.source.id + '_Participant' ),
			targetRef <- a
			),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- a,
			targetRef <- thisModule.getFlowElement(s.target.id)
			)
		do {
			thisModule.getRealFlowElement <- thisModule.getRealFlowElement -> including(c);
			thisModule.collaborations.messageFlows <- thisModule.collaborations.messageFlows.append(b);
			--let s: String = '' in a.name.toString().println(); 
		}
}

-- transform an OutputInput flow to ThrowingMessageEvent, Message Flow, and Sequence flow
rule outputInput2ThrowingMessage_MessageFlow_SequenceFlow{
	from 
		s: EA!EaOutputInputFlow(((s.source.oclIsKindOf(EA!EaExtendedActivity) and not thisModule.isAtomic(s.source)) 
				or s.source.oclIsTypeOf(EA!EaOr) or s.source.oclIsTypeOf(EA!EaAnd)) 
				and (s.target.oclIsTypeOf(EA!EaExternalConnector) or s.target.oclIsTypeOf(EA!EaInternalConnector))
		)
	to
		a:	BPMN!IntermediateThrowEvent(
			id <- s.id + 'throw_1',
			name <- 'MessageThrowhEvent',
			eventDefinitions <- thisModule.messageEventDefinition
			),	
		b:  BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- thisModule.getFlowElement(s.source.id),
			targetRef <- a 
			),
		c: BPMN!MessageFlow(
			id <- s.id + 'Message_1',
			sourceRef <- a,
			targetRef <- thisModule.getParticipant(s.target.id + '_Participant' )
			)	
	do {
		thisModule.getRealFlowElement <- thisModule.getRealFlowElement -> including(b);
		thisModule.collaborations.messageFlows <- thisModule.collaborations.messageFlows.append(c);
	}
}

-- transform a control flow to CatchingMessageEvent, MessageFlow, and SequenceFlow
rule control2CatchingMessage_MessageFlow_SequenceFlow {
	from
		s: EA!EaControlFlow ((s.source.oclIsTypeOf(EA!EaExternalConnector) or s.source.oclIsTypeOf(EA!EaInternalConnector)) 
			and (s.target.oclIsKindOf(EA!EaExtendedActivity) and  not thisModule.isAtomic(s.target)))
	to
		a:	BPMN!IntermediateCatchEvent(
			id <- s.id + 'Catch_1',
			name <- 'MessageCatchEvent'
			),			
		b: BPMN!MessageFlow(
			id <- s.id + 'Message_1',
			sourceRef <- thisModule.getParticipant(s.source.id + '_Participant' ),
			targetRef <- a
			),
		c: BPMN!SequenceFlow (
			id <- s.id + 'Sequence_1',
			sourceRef <- a,
			targetRef <- thisModule.getFlowElement(s.target.id)
			)
		do {
			a.eventDefinitions <- a.eventDefinitions.append(thisModule.messageEventDefinition);
			thisModule.getRealFlowElement <- thisModule.getRealFlowElement.append(c);
			thisModule.collaborations.messageFlows <- thisModule.collaborations.messageFlows.append(b);
		}
}

-- transform a control flow to  MessageFlow
rule control2MessageFlow {
	from
		s: EA!EaControlFlow ((s.source.oclIsTypeOf(EA!EaExternalConnector) or s.source.oclIsTypeOf(EA!EaInternalConnector)) 
			and (s.target.oclIsKindOf(EA!EaExtendedActivity) and  thisModule.isAtomic(s.target)))
	to	
		a: BPMN!MessageFlow(
			id <- s.id + '_1',
			name <- s.name,
			sourceRef <- thisModule.getParticipant(s.source.id + '_Participant' ),
			targetRef <- thisModule.getFlowElement(s.target.id)
		)
	do {
			thisModule.collaborations.messageFlows <- thisModule.collaborations.messageFlows.append(a);
		}
}

-- transform Material resource to DataObject
lazy rule Material2DataObject {
	from 
		s: EA!EaMaterialResource
	using {
		procReal: BPMN!Process = BPMN!Process.allInstances() -> collect (e | e) -> select (e | thisModule.searchRealProcess(e)).first();
	}
	to
		a: BPMN!DataObject(
			id <- s.id,
			name <- s.name
		)
	do {
		procReal.flowElements <- procReal.flowElements -> including(a);
		s.outFlows.debug('outFlows');
		for (e in s.outFlows) {
			thisModule.MaterialResource2DataObject(e);
		}
	}
} 

lazy rule MaterialResource2DataObject {
	from 
		s: EA!EaSupportFlow
	using {
		--procVirtual: BPMN!Process = BPMN!Process.allInstances() -> collect (e | e) -> select (e | thisModule.searchVirtualProcess(e)).first();
		procReal: BPMN!Process = BPMN!Process.allInstances() -> collect (e | e) -> select (e | thisModule.searchRealProcess(e)).first();
	}
	to 
		b: BPMN!Association(
			id <- s.target.id + 'Association_1',
			sourceRef <- thisModule.getDataObject(s.source.id),
			targetRef <- s.target
		)
	do { 	
		procReal.artifacts <- procReal.artifacts -> including(b);
	}
}

-- get required data object for references
helper def: getDataObject(id : String): BPMN!DataObject = BPMN!DataObject.allInstances() -> select (e| e.id.toString().endsWith(id));

-- transform an Internal/External Connector to Process
lazy rule InExternalConnector2Process {
	from
		s: EA!EaConnector(s.oclIsTypeOf(EA!EaExternalConnector) or s.oclIsTypeOf(EA!EaInternalConnector))
	to
		a: BPMN!Process (
			id <- s.id,
			name <- s.name
		)
	do {
		thisModule.bpmnProcess <- thisModule.bpmnProcess -> including(a);
		thisModule.collaborations.participants <- thisModule.collaborations.participants.append(thisModule.ProcessToParticipant(a));	
		--let s: String = '' in a.name.toString().println(); 
	}
}

-- transform a Process Connector to CallActivity
lazy rule ProcessConnector2CallActivity {
	from
		s: EA!EaConnector (s.oclIsTypeOf(EA!EaProcessConnector))
	to
		a: BPMN!CallActivity (
			id <- s.id,
			name <- s.name
		)
}

-- transform a support flow to an association
--rule support2association {
--	from 
--		s: EA!EaSupportFlow(thisModule.isMaterialResource(s))
--	using {
--		procVirtual: BPMN!Process = BPMN!Process.allInstances() -> collect (e | e) -> select (e | thisModule.searchVirtualProcess(e)).first().debug('raios');
--		procReal: BPMN!Process = BPMN!Process.allInstances() -> collect (e | e) -> select (e | thisModule.searchRealProcess(e)).first().debug('raios');
--	}
--	to
--		a: BPMN!Association (
--			id <- s.id + 'Association_1',
--			name <- s.name + 'Association_1',
--			sourceRef <- thisModule.getFlowElement(s.source.id),
--			targetRef <- thisModule.getFlowElement(s.target.id)
--		)
--	do {
--		procVirtual.debug('procVirtual');
--		procReal.debug('procReal');
--		procReal.flowElements <- procReal.flowElements -> including(a);
--		--thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
--		--thisModule.bpmnProcessRef.artifacts <- thisModule.bpmnProcessRef.artifacts -> including(a);		
--	}
--}

-----------------------------------------------------------------------------------------------------
rule Resource2Lane {
	from 
		s: EA!EaResource(not thisModule.isMaterialResource(s))
	using {
		laneName: String = s.name;		
	}
	to
		a: BPMN!Lane(
			id <- s.id + '_Real',
			name <- s.name
		),
		b: BPMN!Lane(
			id <- s.id + '_Virtual',
			name <- s.name
		)
	do {		
		if (thisModule.getActivityWorld(s) = 'two') {
			if(not thisModule.realWorldLanes -> includes(laneName)) {
				thisModule.getNamedLaneSet('RealWorldLaneSet') -> first().lanes <- thisModule.getNamedLaneSet('RealWorldLaneSet')
					-> first().lanes -> including(a);
			}
			thisModule.realWorldLanes <- Set {thisModule.realWorldLanes, laneName};
			
			if(not thisModule.virtualWorldLanes -> includes(laneName)) {
				thisModule.getNamedLaneSet('VirtualWorldLaneSet') -> first().lanes <- thisModule.getNamedLaneSet('VirtualWorldLaneSet')
					-> first().lanes -> including(b);
			}
			thisModule.virtualWorldLanes <- Set {thisModule.virtualWorldLanes, laneName};
			
			a.flowNodeRefs <- (thisModule.createFlowNodeRefs(s.id) -> select (e | e.osmoseWorld = 'REAL'));
			b.flowNodeRefs <- (thisModule.createFlowNodeRefs(s.id) -> select (e | e.osmoseWorld = 'VIRTUAL'));
		} else {
			if (thisModule.getActivityWorld(s) = 'REAL') {
				a.flowNodeRefs <- thisModule.createFlowNodeRefs(s.id);
				if(not thisModule.realWorldLanes -> includes(laneName)) {		
					thisModule.getNamedLaneSet('RealWorldLaneSet') -> first().lanes <- thisModule.getNamedLaneSet('RealWorldLaneSet')
						-> first().lanes -> including(a);
				}
				thisModule.realWorldLanes <- Set {thisModule.realWorldLanes, laneName};
			}
			if (thisModule.getActivityWorld(s) = 'VIRTUAL') {
				b.flowNodeRefs <- thisModule.createFlowNodeRefs(s.id);
				if(not thisModule.virtualWorldLanes -> includes(laneName)){
					thisModule.getNamedLaneSet('VirtualWorldLaneSet') -> first().lanes <- thisModule.getNamedLaneSet('VirtualWorldLaneSet')
						-> first().lanes -> including(b);
				}
				thisModule.virtualWorldLanes <- Set {thisModule.virtualWorldLanes, laneName};
			}
		}
	}
}

rule Organization2Lane { 
	from 
		s: EA!EaOrganization
	using {
		laneName: String = s.name;
		laneSetName: String = s.name + '_LaneSet';
	}
	to
		laneset:BPMN!LaneSet(
			id <- s.name + '_LaneSet',
			name <- s.name + '_LaneSet'
		),
		a: BPMN!Lane(
			id <- s.id,
			name <- s.name,
			childLaneSet <- laneset,
			flowNodeRefs <- a.flowNodeRefs -> including(thisModule.createFlowNodeRefsForOrganization(s.id))
		)
	do {		
		thisModule.realWorldLanes <- Set {thisModule.realWorldLanes, laneName};	
		thisModule.orgChildLaneSet <- Set {thisModule.orgChildLaneSet, laneset};
	}		
}

rule CreateLane (laneName: OclAny, LaneSet: OclAny) {
	to
			lane : BPMN!Lane (
			name <- laneName,
			id <- laneName		
		)
	do {
		LaneSet.lanes <- LaneSet.lanes -> including(lane);
		if (laneName = 'Membrane') {
			lane.flowNodeRefs <- thisModule.membraneFlowElements -> select(x | not x.oclIsTypeOf(BPMN!SequenceFlow));
		}
		if (laneName = 'Virtualization') {
			lane.flowNodeRefs <- thisModule.virtualizationFlowElements -> select(x | not x.oclIsTypeOf(BPMN!SequenceFlow));
		}
	}
}

rule CreateLaneSet (laneName: OclAny, LaneSet: OclAny) {
	to
		laneSet: BPMN!LaneSet(
			name <- laneName,
			id <- laneName
		)	
}

rule MembraneStartingTask() {
	to
		a: BPMN!Task (
			id <- 'waitingForEvent',
			name <- 'Waiting for an event'
		),
		b: BPMN!StartEvent(
			id <- 'coisoStart',
			name <- 'StartEvent'
		),
		c: BPMN!SequenceFlow (
			id <- 'coisoSequence_1',
			sourceRef <- b,
			targetRef <- a
		)
	do {
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(a);
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(b);
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(c);
--		let s: String = ''	in 	thisModule.membraneFlowElements->select(z|z.oclIsKindOf(BPMN!SequenceFlow)).size().toString().println();  
	}
}

rule MembraneElements() {
	to
		a: BPMN!Task (
			id <- 'checking',
			name <- 'Check Osmose Event Type'
		),
		b: BPMN!Task (
			id <- 'doNothing',
			name <- 'Do nothing'
		),
		c: BPMN!Task (
			id <- 'startInternalProcess',
			name <- 'Start Internal Process'
		),
--		d: BPMN!IntermediateCatchEvent (
--			id <- 'receiveEvent',
--			name <- 'Receive event'
--		),
		e: BPMN!ExclusiveGateway(
			id<- 'decisionPoint',
			name <- 'Decision point',
			gatewayDirection <- 'Diverging'
		),
--		f: BPMN!IntermediateThrowEvent(
--			id <- 'reactToOsmioticEvent',
--			name <- 'React to Osmiotic event'
--		),
		g: BPMN!EndEvent(
			id <- 'membraneEndEvent1',
			name <- 'EndEvent'
		),
		h: BPMN!EndEvent(
			id <- 'membraneEndEvent2',
			name <- 'EndEvent'
		)
	do {
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(a);
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(b);
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(c);
--		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(d);
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(e);
--		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(f);
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(g);
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(h);
	}
}

rule VirtualizationElements() {
	to
		a: BPMN!Task (
			id <- 'TaskToEnd',
			name <- 'Virtualization tasks'
		),
		b: BPMN!EndEvent(
			id <- 'SimulationEndEvent',
			name <- 'EndEvent'
		)
	do {
		thisModule.virtualizationFlowElements <- thisModule.virtualizationFlowElements->including(a);
		thisModule.virtualizationFlowElements <- thisModule.virtualizationFlowElements->including(b);
	}
}

rule MembraneSequenceFlows(){ --check
	to
		a: BPMN!SequenceFlow (
			id <- 'waitingForReceive',
			sourceRef <- thisModule.membraneFlowElements->select(z | z.id = 'waitingForEvent')->first(),
			targetRef <- thisModule.membraneFlowElements->select(z | z.id = 'checking')->first()
		),
--		b: BPMN!SequenceFlow (
--			id <- 'ReceiveForChecking',
--			sourceRef <- thisModule.membraneFlowElements->select(z | z.id = 'receiveEvent')->first(),
--			targetRef <- thisModule.membraneFlowElements->select(z | z.id = 'checking')->first()
--		),
		c: BPMN!SequenceFlow (
			id <- 'CheckingToDecision',
			sourceRef <- thisModule.membraneFlowElements->select(z | z.id = 'checking')->first(),
			targetRef <- thisModule.membraneFlowElements->select(z | z.id = 'decisionPoint')->first()
		), 
		d: BPMN!SequenceFlow (
			id <- 'DecisionToNothing',
			sourceRef <- thisModule.membraneFlowElements->select(z | z.id = 'decisionPoint')->first(),
			targetRef <- thisModule.membraneFlowElements->select(z | z.id = 'doNothing')->first()
		), 
		e: BPMN!SequenceFlow (
			id <- 'DecisionToInternalProcess',
			sourceRef <- thisModule.membraneFlowElements->select(z | z.id = 'decisionPoint')->first(),
			targetRef <- thisModule.membraneFlowElements->select(z | z.id = 'startInternalProcess')->first()
		),
		f: BPMN!SequenceFlow (
			id <- 'fromNothingToEnd',
			sourceRef <- thisModule.membraneFlowElements->select(z | z.id = 'doNothing')->first(),
			targetRef <- thisModule.membraneFlowElements->select(z | z.id = 'membraneEndEvent1')->first()
		),
		g: BPMN!SequenceFlow (
			id <- 'fromInternalToEnd',
			sourceRef <- thisModule.membraneFlowElements->select(z | z.id = 'startInternalProcess')->first(),
			targetRef <- thisModule.membraneFlowElements->select(z | z.id = 'membraneEndEvent2')->first()
		),
		h: BPMN!SequenceFlow (
			id <- 'DecisionToReactOsmiotic',
			sourceRef <- thisModule.membraneFlowElements->select(z | z.id = 'decisionPoint')->first(),
			targetRef <- thisModule.virtualizationFlowElements->select(z | z.id = 'TaskToEnd')->first()
			--targetRef <- thisModule.membraneFlowElements->select(z | z.id = 'reactToOsmioticEvent')->first()
		)--,
--		i: BPMN!SequenceFlow (
--			id <- 'ReactToSimulation',
--			sourceRef <- thisModule.membraneFlowElements->select(z | z.id = 'reactToOsmioticEvent')->first(),
--			targetRef <- thisModule.virtualizationFlowElements->select(z | z.id = 'TaskToEnd')->first()
--		)	
	do {
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(a);
--		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(b);
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(c);
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(d);
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(e);
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(f);
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(g);
		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(h);
--		thisModule.membraneFlowElements <- thisModule.membraneFlowElements->including(i);
	}	
}

rule VirtualizationSequenceFlows() {
	to
		a: BPMN!SequenceFlow (
			id <- 'fromSimulationToEnd',
			sourceRef <- thisModule.virtualizationFlowElements->select(z | z.id = 'TaskToEnd') -> first(),
			targetRef <- thisModule.virtualizationFlowElements->select(z | z.id = 'SimulationEndEvent') -> first()
		)
	do {
		thisModule.virtualizationFlowElements <- thisModule.virtualizationFlowElements->including(a);
	}
}

-------------------------------------------------------------------------------------------------
lazy rule ProcessToParticipant {
	from
		s: EA!EaProcess (
			s.oclIsKindOf(EA!EaProcess)
		)
	to
		a: BPMN!Participant (
			id <- s.id + '_Participant',
			name <- s.name,
			processRef <- thisModule.bpmnProcess
		)
	do { }
}

rule findMissingEndEvents() {
	using {
		task: BPMN!Task = BPMN!Task.allInstances() -> select (e | e.outgoing.size() = 0);
	}
	do {
		for (e in task) {
			thisModule.detectElementsOfEndEvent(e);
		}
	}
}
	
rule detectElementsOfEndEvent(task: BPMN!Task) {
	using {
		procVirtual: BPMN!Process = BPMN!Process.allInstances() -> collect (e | e) -> select (e | thisModule.searchVirtualProcess(e)).first();
		procReal: BPMN!Process = BPMN!Process.allInstances() -> collect (e | e) -> select (e | thisModule.searchRealProcess(e)).first();
		taskBelongs2Virtual: String = procVirtual.flowElements -> select (e | e.id.toString() = task.id.toString());
		taskBelongs2Real: String = procReal.flowElements -> select (e | e.id.toString() = task.id.toString());
	}
	do {
		if (not taskBelongs2Virtual.isEmpty()) {
			thisModule.createNewEndEvent(task, 'VIRTUAL', procVirtual, thisModule.getLane(task));
		}
		if (not taskBelongs2Real.isEmpty()) {
			thisModule.createNewEndEvent(task, 'REAL', procReal, thisModule.getLane(task));
		}
	}
}

rule createNewEndEvent(task: BPMN!Task, world: String, proc: BPMN!Process, resource: BPMN!Lane) {
	to
		a: BPMN!EndEvent (
			id <- task.id + '_End',
			name <- task.name + '_EndEvent'
		),
		b: BPMN!SequenceFlow (
			id <- task.id + '_SequenceFlow',
			name <- task.name + '_SequenceFlow',
			sourceRef <- task,
			targetRef <- a
		)
	do {
		if (world = 'VIRTUAL') {
			thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
			resource.flowNodeRefs <- resource.flowNodeRefs -> including(a);
			proc.flowElements <- proc.flowElements -> including(a);
			proc.flowElements <- proc.flowElements -> including(b);
		}
		if (world = 'REAL') {
			thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
			resource.flowNodeRefs <- resource.flowNodeRefs -> including(a);
			proc.flowElements <- proc.flowElements -> including(a);
			proc.flowElements <- proc.flowElements -> including(b);
		}
	}
}

rule findMissingStartEvents() {
	using {
		task: BPMN!Task = BPMN!Task.allInstances() -> select (e | e.incoming.size() = 0);
	}
	do {
		for (e in task) {
			thisModule.detectElementsOfStartEvent(e);
		}
	}
}

rule detectElementsOfStartEvent(task: BPMN!Task) {
	using {
		procVirtual: BPMN!Process = BPMN!Process.allInstances() -> collect (e | e) -> select (e | thisModule.searchVirtualProcess(e)).first();
		procReal: BPMN!Process = BPMN!Process.allInstances() -> collect (e | e) -> select (e | thisModule.searchRealProcess(e)).first();
		taskBelongs2Virtual: String = procVirtual.flowElements -> select (e | e.id.toString() = task.id.toString());
		taskBelongs2Real: String = procReal.flowElements -> select (e | e.id.toString() = task.id.toString());
	}
	do {
		if (not taskBelongs2Virtual.isEmpty()) {
			thisModule.createNewStartEvent(task, 'VIRTUAL', procVirtual, thisModule.getLane(task));
		}
		if (not taskBelongs2Real.isEmpty()) {
			thisModule.createNewStartEvent(task, 'REAL', procReal, thisModule.getLane(task));
		}
	}
}

rule createNewStartEvent(task: BPMN!Task, world: String, proc: BPMN!Process, resource: BPMN!Lane) {
	to
		a: BPMN!StartEvent (
			id <- task.id + '_Start',
			name <- task.name + '_StartEvent'
		),
		b: BPMN!SequenceFlow (
			id <- task.id + '_SequenceFlow',
			name <- task.name + '_SequenceFlow',
			sourceRef <- a,
			targetRef <- task
		)
	do {
		if (world = 'VIRTUAL') {
			thisModule.virtualFlowElements <- thisModule.virtualFlowElements -> including(a);
			resource.flowNodeRefs <- resource.flowNodeRefs -> including(a);
			proc.flowElements <- proc.flowElements -> including(a);
			proc.flowElements <- proc.flowElements -> including(b);
		}
		if (world = 'REAL') {
			thisModule.realFlowElements <- thisModule.realFlowElements -> including(a);
			resource.flowNodeRefs <- resource.flowNodeRefs -> including(a);
			proc.flowElements <- proc.flowElements -> including(a);
			proc.flowElements <- proc.flowElements -> including(b);
		}
	}
}

endpoint rule validateSequenceFlow() {
	do {
		thisModule.findMissingStartEvents();
		thisModule.findMissingEndEvents();
	}
}